#pragma once
#include "Application.h"
#include "RsmTechnique.h"
#include "SceneLoader.h"
#include "PCG.h"
#include "techniques/Bloom.h"
#include "techniques/AutoExposure.h"
#include "techniques/VirtualShadowMaps.h"

#include <Fwog/Texture.h>

#ifdef FROGRENDER_FSR2_ENABLE
  #include "src/ffx-fsr2-api/ffx_fsr2.h"
  #include "src/ffx-fsr2-api/gl/ffx_fsr2_gl.h"
#endif

namespace Debug
{
  struct Line
  {
    glm::vec3 aPosition;
    glm::vec4 aColor;
    glm::vec3 bPosition;
    glm::vec4 bColor;
  };

  struct Aabb
  {
    glm::vec3 center;
    glm::vec3 halfExtent;
    glm::vec4 color;
  };

  struct Rect
  {
    glm::vec2 minOffset;
    glm::vec2 maxOffset;
    glm::vec4 color;
    float depth;
  };
}

class FrogRenderer final : public Application
{
public:
  FrogRenderer(const Application::CreateInfo& createInfo, std::optional<std::string_view> filename, float scale, bool binary);

private:
  struct ObjectUniforms
  {
    glm::mat4 model;
  };

  struct GlobalUniforms
  {
    glm::mat4 viewProj;
    glm::mat4 oldViewProjUnjittered;
    glm::mat4 viewProjUnjittered;
    glm::mat4 invViewProj;
    glm::mat4 proj;
    glm::vec4 cameraPos;
    uint32_t meshletCount;
    uint32_t maxIndices;
    float bindlessSamplerLodBias;
    uint32_t _padding[1];
  };

  struct View {
    glm::mat4 oldProj;
    glm::mat4 oldView;
    glm::mat4 oldViewProj;
    glm::mat4 proj;
    glm::mat4 view;
    glm::mat4 viewProj;
    glm::vec4 cameraPos;
    glm::vec4 frustumPlanes[6];
    glm::vec4 viewport;
  };

  struct ShadingUniforms
  {
    glm::mat4 sunViewProj;
    glm::vec4 sunDir;
    glm::vec4 sunStrength;
    glm::mat4 sunView;
    glm::mat4 sunProj;
    glm::vec2 random;
    glm::uint numberOfLights;
    glm::uint _padding;
  };

  struct ShadowUniforms
  {
    uint32_t shadowMode = 0; // 0 = PCF, 1 = SMRT

    // PCF stuff
    uint32_t pcfSamples = 8;
    float pcfRadius = 0.002f;

    // SMRT stuff
    uint32_t shadowRays = 7;
    uint32_t stepsPerRay = 7;
    float rayStepSize = 0.1f;
    float heightmapThickness = 0.5f;
    float sourceAngleRad = 0.05f;
  };

  struct TonemapUniforms
  {
    float saturation = 1.0f;
    float agxDsLinearSection = 0.18f;
    float peak = 1.0f;
    float compression = 0.15f;
    uint32_t enableDithering = true;
  };

  void OnWindowResize(uint32_t newWidth, uint32_t newHeight) override;
  void OnUpdate(double dt) override;
  void OnRender(double dt) override;
  void OnGui(double dt) override;

  void InitGui();
  void GuiDrawMagnifier(glm::vec2 viewportContentOffset, glm::vec2 viewportContentSize, bool viewportIsHovered);
  void GuiDrawDockspace();
  void GuiDrawFsrWindow();
  void GuiDrawDebugWindow();
  void GuiDrawLightsArray();
  void GuiDrawBloomWindow();
  void GuiDrawAutoExposureWindow();
  void GuiDrawCameraWindow();

  // constants
  static constexpr int gMaxViews = 16;
  static constexpr int gMaxCascades = 4;
  static constexpr int gShadowmapWidth = 2048;
  static constexpr int gShadowmapHeight = 2048;

  double rsmPerformance = 0;
  double fsr2Performance = 0;

  // scene parameters
  float sunElevation = 3.0f;
  float sunAzimuth = 0.3f;
  float sunStrength = 50;
  glm::vec3 sunColor = {1, 1, 1};

  float aspectRatio = 1;

  // True: output size will be equal to GUI viewport resolution
  // False: output size will be equal to window resolution
  bool useGuiViewportSizeForRendering = true;

  // Debugging stuff
  bool updateCullingFrustum = true;
  bool generateHizBuffer = true;
  bool executeMeshletGeneration = true;
  bool drawDebugAabbs = false;
  bool clearDebugAabbsEachFrame = true;
  bool drawDebugRects = false;
  bool clearDebugRectsEachFrame = true;
  int fakeLag = 0;
  bool debugRenderToSwapchain = false;

  // Indirect command and array of cubes that are generated by the GPU. Fixed size buffer!
  std::optional<Fwog::Buffer> debugGpuAabbsBuffer;

  // Indirect command and array of rects (not quads!) generated by the GPU. Fixed size buffer
  std::optional<Fwog::Buffer> debugGpuRectsBuffer;

  // List of debug lines to be drawn. Cleared every frame.
  std::vector<Debug::Line> debugLines;
  bool debugDisplayMainFrustum = false;
  glm::mat4 debugMainViewProj{1};

  // Resources tied to the output resolution
  struct Frame
  {
    // Main view visbuffer
    std::optional<Fwog::Texture> visbuffer;
    std::optional<Fwog::Texture> materialDepth;
    std::optional<Fwog::Texture> hzb;

    // G-buffer textures
    std::optional<Fwog::Texture> gAlbedo;
    std::optional<Fwog::Texture> gMetallicRoughnessAo;
    std::optional<Fwog::Texture> gNormal;
    std::optional<Fwog::Texture> gEmission;
    std::optional<Fwog::Texture> gMotion;
    std::optional<Fwog::Texture> gDepth;
    std::optional<Fwog::Texture> gReactiveMask; // FSR 2 reactive mask texture

    // Previous-frame G-buffer textures used for temporal effects
    std::optional<Fwog::Texture> gNormalPrev;
    std::optional<Fwog::Texture> gDepthPrev;

    // Post-lighting
    std::optional<Fwog::Texture> colorHdrRenderRes;

    // Post-upscale (skipped if render res == window res)
    std::optional<Fwog::Texture> colorHdrWindowRes;

    // Bloom scratch buffer. Half window resolution.
    std::optional<Fwog::Texture> colorHdrBloomScratchBuffer;

    // Final tonemapped color
    std::optional<Fwog::Texture> colorLdrWindowRes;

    // Per-technique frame resources
    std::optional<RSM::RsmTechnique> rsm;

    // For debug drawing with ImGui
    std::optional<Fwog::TextureView> gAlbedoSwizzled;
    std::optional<Fwog::TextureView> gRoughnessMetallicAoSwizzled;
    std::optional<Fwog::TextureView> gEmissionSwizzled;
    std::optional<Fwog::TextureView> gNormalSwizzled;
    std::optional<Fwog::TextureView> gDepthSwizzled;
    std::optional<Fwog::TextureView> gRsmIlluminanceSwizzled;
  };
  Frame frame{};

  // Reflective shadow map textures
  Fwog::Texture rsmFlux;
  Fwog::Texture rsmNormal;
  Fwog::Texture rsmDepth;

  // Cascaded Shadow Maps
  Fwog::Texture shadowCascades;

  // For debug drawing with ImGui
  Fwog::TextureView rsmFluxSwizzled;
  Fwog::TextureView rsmNormalSwizzled;
  Fwog::TextureView rsmDepthSwizzled;

  ShadingUniforms shadingUniforms{};
  ShadowUniforms shadowUniforms{};
  GlobalUniforms mainCameraUniforms{};

  Fwog::TypedBuffer<GlobalUniforms> globalUniformsBuffer;
  Fwog::TypedBuffer<ShadingUniforms> shadingUniformsBuffer;
  Fwog::TypedBuffer<ShadowUniforms> shadowUniformsBuffer;

  // Meshlet stuff
  std::optional<Fwog::TypedBuffer<Utility::Meshlet>> meshletBuffer;
  std::optional<Fwog::TypedBuffer<Utility::Vertex>> vertexBuffer;
  std::optional<Fwog::TypedBuffer<uint32_t>> indexBuffer;
  std::optional<Fwog::TypedBuffer<uint8_t>> primitiveBuffer;
  std::optional<Fwog::TypedBuffer<glm::mat4>> transformBuffer;
  std::optional<Fwog::TypedBuffer<Utility::GpuMaterial>> materialStorageBuffer;
  std::optional<Fwog::TypedBuffer<View>> viewBuffer;
  // Output
  std::optional<Fwog::TypedBuffer<Fwog::DrawIndexedIndirectCommand>> meshletIndirectCommand;
  std::optional<Fwog::TypedBuffer<uint32_t>> instancedMeshletBuffer;

  Fwog::TypedBuffer<glm::mat4> rsmUniforms;

  Fwog::ComputePipeline meshletGeneratePipeline;
  Fwog::ComputePipeline hzbCopyPipeline;
  Fwog::ComputePipeline hzbReducePipeline;
  Fwog::GraphicsPipeline visbufferPipeline;
  Fwog::GraphicsPipeline shadowMainPipeline;
  Fwog::GraphicsPipeline materialDepthPipeline;
  Fwog::GraphicsPipeline visbufferResolvePipeline;
  //Fwog::GraphicsPipeline rsmScenePipeline;
  Fwog::GraphicsPipeline shadingPipeline;
  Fwog::ComputePipeline tonemapPipeline;
  Fwog::GraphicsPipeline debugTexturePipeline;
  Fwog::GraphicsPipeline debugLinesPipeline;
  Fwog::GraphicsPipeline debugAabbsPipeline;
  Fwog::GraphicsPipeline debugRectsPipeline;

  // Scene
  Utility::SceneMeshlet scene;

  // Punctual lights
  std::optional<Fwog::TypedBuffer<Utility::GpuLight>> lightBuffer;
  std::optional<Fwog::TypedBuffer<ObjectUniforms>> meshUniformBuffer;

  // Post processing
  std::optional<Fwog::Texture> noiseTexture;
  Fwog::TypedBuffer<TonemapUniforms> tonemapUniformBuffer;
  TonemapUniforms tonemapUniforms{};

  uint32_t renderWidth;
  uint32_t renderHeight;
  uint32_t frameIndex = 0;
  uint32_t seed = PCG::Hash(17);

#ifdef FROGRENDER_FSR2_ENABLE
  // FSR 2
  bool fsr2Enable = true;
  bool fsr2FirstInit = true;
  float fsr2Sharpness = 0;
  float fsr2Ratio = 1.7f; // FFX_FSR2_QUALITY_MODE_BALANCED
  FfxFsr2Context fsr2Context;
  std::unique_ptr<char[]> fsr2ScratchMemory;
#else
  const bool fsr2Enable = false;
#endif

  // Magnifier
  float magnifierZoom = 4;
  glm::vec2 magnifierLastCursorPos = {400, 400};

  // Bloom
  Techniques::Bloom bloom;
  bool bloomEnable = true;
  uint32_t bloomPasses = 6;
  float bloomStrength = 1.0f / 32.0f;
  float bloomWidth = 1.0f;
  bool bloomUseLowPassFilter = true;

  // Auto-exposure
  Techniques::AutoExposure autoExposure;
  Fwog::TypedBuffer<float> exposureBuffer;
  float autoExposureLogMinLuminance = -15.0f;
  float autoExposureLogMaxLuminance = 15.0f;
  // sRGB middle gray (https://en.wikipedia.org/wiki/Middle_gray)
  float autoExposureTargetLuminance = 0.2140f;
  float autoExposureAdjustmentSpeed = 1.0f;

  // Camera
  float cameraNearPlane = 0.1f;
  float cameraFovyRadians = glm::radians(70.0f);

  // VSM
  Techniques::VirtualShadowMaps::Context vsmContext;
  Techniques::VirtualShadowMaps::DirectionalVirtualShadowMap vsmSun;
};
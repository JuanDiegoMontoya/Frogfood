#pragma once
#include "Application.h"
#include "SceneLoader.h"
#include "PCG.h"

#ifdef FROGRENDER_FSR2_ENABLE
  #include "src/ffx-fsr2-api/ffx_fsr2.h"
  //#include "src/ffx-fsr2-api/vk/ffx_fsr2_vk.h"
#endif

#include "Fvog/Texture2.h"
#include "Fvog/Buffer2.h"
#include "Fvog/Pipeline2.h"

namespace Debug
{
  struct Line
  {
    glm::vec3 aPosition;
    glm::vec4 aColor;
    glm::vec3 bPosition;
    glm::vec4 bColor;
  };

  struct Aabb
  {
    glm::vec3 center;
    glm::vec3 halfExtent;
    glm::vec4 color;
  };

  struct Rect
  {
    glm::vec2 minOffset;
    glm::vec2 maxOffset;
    glm::vec4 color;
    float depth;
  };
} // namespace Debug

class FrogRenderer2 final : public Application
{
public:
  FrogRenderer2(const Application::CreateInfo& createInfo);
  ~FrogRenderer2();

private:
  void OnWindowResize(uint32_t newWidth, uint32_t newHeight) override;
  void OnUpdate(double dt) override;
  void OnRender(double dt, VkCommandBuffer commandBuffer, uint32_t swapchainImageIndex) override;
  void OnGui(double dt) override;
  void OnPathDrop(std::span<const char*> paths) override;

  

  enum class GlobalFlags : uint32_t
  {
    CULL_MESHLET_FRUSTUM    = 1 << 0,
    CULL_MESHLET_HIZ        = 1 << 1,
    CULL_PRIMITIVE_BACKFACE = 1 << 2,
    CULL_PRIMITIVE_FRUSTUM  = 1 << 3,
    CULL_PRIMITIVE_SMALL    = 1 << 4,
    CULL_PRIMITIVE_VSM      = 1 << 5,
    USE_HASHED_TRANSPARENCY = 1 << 6,
  };

  struct GlobalUniforms
  {
    glm::mat4 viewProj;
    glm::mat4 oldViewProjUnjittered;
    glm::mat4 viewProjUnjittered;
    glm::mat4 invViewProj;
    glm::mat4 proj;
    glm::mat4 invProj;
    glm::vec4 cameraPos;
    uint32_t meshletCount;
    uint32_t maxIndices;
    float bindlessSamplerLodBias;
    uint32_t flags = 
      (uint32_t)GlobalFlags::CULL_MESHLET_FRUSTUM |
      (uint32_t)GlobalFlags::CULL_MESHLET_HIZ /*|
      (uint32_t)GlobalFlags::CULL_PRIMITIVE_BACKFACE |
      (uint32_t)GlobalFlags::CULL_PRIMITIVE_FRUSTUM |
      (uint32_t)GlobalFlags::CULL_PRIMITIVE_SMALL |
      (uint32_t)GlobalFlags::CULL_PRIMITIVE_VSM*/
    | (uint32_t)GlobalFlags::USE_HASHED_TRANSPARENCY
      ;
    float alphaHashScale = 1.0;
    uint32_t _padding[3];
  };

  enum class ViewType : uint32_t
  {
    MAIN    = 0,
    VIRTUAL = 1,
  };

  struct View
  {
    glm::mat4 oldProj;
    glm::mat4 oldView;
    glm::mat4 oldViewProj;
    glm::mat4 proj;
    glm::mat4 view;
    glm::mat4 viewProj;
    glm::mat4 viewProjStableForVsmOnly;
    glm::vec4 cameraPos;
    glm::vec4 frustumPlanes[6];
    glm::vec4 viewport;
    ViewType type = ViewType::MAIN;
    glm::uint virtualTableIndex;
    glm::uvec2 _padding;
  };

  enum class ShadingDebugFlag : uint32_t
  {
    VSM_SHOW_CLIPMAP_ID    = 1 << 0,
    VSM_SHOW_PAGE_ADDRESS  = 1 << 1,
    VSM_SHOW_PAGE_OUTLINES = 1 << 2,
    VSM_SHOW_SHADOW_DEPTH  = 1 << 3,
    VSM_SHOW_DIRTY_PAGES   = 1 << 4,
    BLEND_NORMALS          = 1 << 5,
  };
  //FWOG_DECLARE_FLAG_TYPE(ShadingDebugFlags, ShadingDebugFlag, uint32_t)

  struct ShadingUniforms
  {
    glm::vec4 sunDir;
    glm::vec4 sunStrength;
    glm::vec2 random;
    glm::uint numberOfLights;
    uint32_t debugFlags{};
  };

  struct ShadowUniforms
  {
    uint32_t shadowMode = 0; // 0 = PCSS, 1 = SMRT

    // PCSS stuff
    uint32_t pcfSamples = 16;
    float lightWidth = 0.002f;
    float maxPcfRadius = 0.032f;
    uint32_t blockerSearchSamples = 16;
    float blockerSearchRadius = 0.032f;

    // SMRT stuff
    uint32_t shadowRays = 7;
    uint32_t stepsPerRay = 7;
    float rayStepSize = 0.1f;
    float heightmapThickness = 0.5f;
    float sourceAngleRad = 0.05f;
  };

  struct TonemapUniforms
  {
    float saturation = 1.0f;
    float agxDsLinearSection = 0.18f;
    float peak = 1.0f;
    float compression = 0.15f;
    uint32_t enableDithering = true;
  };

  // scene parameters
  float sunElevation = 3.0f;
  float sunAzimuth = 0.3f;
  float sunStrength = 50;
  glm::vec3 sunColor = {1, 1, 1};

  float aspectRatio = 1;

  // True: output size will be equal to GUI viewport resolution
  // False: output size will be equal to window resolution
  bool useGuiViewportSizeForRendering = true;

  // Debugging stuff
  bool updateCullingFrustum = true;
  bool generateHizBuffer = true;
  bool executeMeshletGeneration = true;
  bool drawDebugAabbs = false;
  bool clearDebugAabbsEachFrame = true;
  bool drawDebugRects = false;
  bool clearDebugRectsEachFrame = true;
  int fakeLag = 0;

  // Indirect command and array of cubes that are generated by the GPU. Fixed size buffer!
  std::optional<Fvog::Buffer> debugGpuAabbsBuffer;

  // Indirect command and array of rects (not quads!) generated by the GPU. Fixed size buffer
  std::optional<Fvog::Buffer> debugGpuRectsBuffer;

  // List of debug lines to be drawn. Cleared every frame.
  std::vector<Debug::Line> debugLines;
  bool debugDisplayMainFrustum = false;
  glm::mat4 debugMainViewProj{1};

    // Resources tied to the output resolution
  struct Frame
  {
    // Main view visbuffer
    std::optional<Fvog::Texture> visbuffer;
    constexpr static Fvog::Format visbufferFormat = Fvog::Format::R32_UINT;
    std::optional<Fvog::Texture> materialDepth;
    constexpr static Fvog::Format materialDepthFormat = Fvog::Format::D32_SFLOAT;
    std::optional<Fvog::Texture> hzb;
    constexpr static Fvog::Format hzbFormat = Fvog::Format::R32_SFLOAT;

    // G-buffer textures
    std::optional<Fvog::Texture> gAlbedo;
    constexpr static Fvog::Format gAlbedoFormat = Fvog::Format::R8G8B8A8_SRGB;
    std::optional<Fvog::Texture> gMetallicRoughnessAo;
    constexpr static Fvog::Format gMetallicRoughnessAoFormat = Fvog::Format::R8G8B8A8_UNORM;
    std::optional<Fvog::Texture> gNormalAndFaceNormal;
    constexpr static Fvog::Format gNormalAndFaceNormalFormat = Fvog::Format::R16G16B16A16_SNORM;
    std::optional<Fvog::Texture> gSmoothVertexNormal;
    constexpr static Fvog::Format gSmoothVertexNormalFormat = Fvog::Format::R16G16_SNORM;
    std::optional<Fvog::Texture> gEmission;
    constexpr static Fvog::Format gEmissionFormat = Fvog::Format::B10G11R11_UFLOAT;
    std::optional<Fvog::Texture> gDepth;
    constexpr static Fvog::Format gDepthFormat = Fvog::Format::D32_SFLOAT;
    std::optional<Fvog::Texture> gMotion;
    constexpr static Fvog::Format gMotionFormat = Fvog::Format::R16G16_SFLOAT;
    std::optional<Fvog::Texture> gReactiveMask; // FSR 2 reactive mask texture
    constexpr static Fvog::Format gReactiveMaskFormat = Fvog::Format::R32_SFLOAT;

    // Previous-frame G-buffer textures used for temporal effects
    std::optional<Fvog::Texture> gNormaAndFaceNormallPrev;
    constexpr static Fvog::Format gNormaAndFaceNormallPrevFormat = gNormalAndFaceNormalFormat;
    std::optional<Fvog::Texture> gDepthPrev;
    constexpr static Fvog::Format gDepthPrevFormat = gDepthFormat;

    // Post-lighting
    std::optional<Fvog::Texture> colorHdrRenderRes;
    constexpr static Fvog::Format colorHdrRenderResFormat = Fvog::Format::B10G11R11_UFLOAT;

    // Post-upscale (skipped if render res == window res)
    std::optional<Fvog::Texture> colorHdrWindowRes;
    constexpr static Fvog::Format colorHdrWindowResFormat = colorHdrRenderResFormat;

    // Bloom scratch buffer. Half window resolution.
    std::optional<Fvog::Texture> colorHdrBloomScratchBuffer;
    constexpr static Fvog::Format colorHdrBloomScratchBufferFormat = Fvog::Format::B10G11R11_UFLOAT;

    // Final tonemapped color
    std::optional<Fvog::Texture> colorLdrWindowRes;
    constexpr static Fvog::Format colorLdrWindowResFormat = Fvog::Format::R8G8B8A8_UNORM;

    //// For debug drawing with ImGui
    //std::optional<Fvog::TextureView> gAlbedoSwizzled;
    //std::optional<Fvog::TextureView> gRoughnessMetallicAoSwizzled;
    //std::optional<Fvog::TextureView> gEmissionSwizzled;
    //std::optional<Fvog::TextureView> gNormalSwizzled;
    //std::optional<Fvog::TextureView> gDepthSwizzled;
  };
  Frame frame{};

  ShadingUniforms shadingUniforms{};
  ShadowUniforms shadowUniforms{};
  GlobalUniforms globalUniforms{};

  Fvog::NDeviceBuffer<GlobalUniforms> globalUniformsBuffer;
  Fvog::NDeviceBuffer<ShadingUniforms> shadingUniformsBuffer;
  Fvog::NDeviceBuffer<ShadowUniforms> shadowUniformsBuffer;

  // Meshlet stuff
  std::optional<Fvog::TypedBuffer<Utility::Vertex>> vertexBuffer;
  std::optional<Fvog::TypedBuffer<uint32_t>> indexBuffer;
  std::optional<Fvog::TypedBuffer<uint8_t>> primitiveBuffer;
  std::optional<Fvog::TypedBuffer<Utility::ObjectUniforms>> transformBuffer;
  std::optional<Fvog::TypedBuffer<Utility::GpuMaterial>> materialStorageBuffer;
  std::optional<Fvog::TypedBuffer<View>> viewBuffer;
  // Output
  std::optional<Fvog::TypedBuffer<Fvog::DrawIndexedIndirectCommand>> meshletIndirectCommand;
  std::optional<Fvog::TypedBuffer<uint32_t>> instancedMeshletBuffer;
  std::optional<Fvog::TypedBuffer<Fvog::DispatchIndirectCommand>> cullTrianglesDispatchParams;
  std::optional<Fvog::TypedBuffer<uint32_t>> visibleMeshletIds;

  Fvog::ComputePipeline cullMeshletsPipeline;
  Fvog::ComputePipeline cullTrianglesPipeline;
  Fvog::ComputePipeline hzbCopyPipeline;
  Fvog::ComputePipeline hzbReducePipeline;
  Fvog::GraphicsPipeline visbufferPipeline;
  Fvog::GraphicsPipeline materialDepthPipeline;
  Fvog::GraphicsPipeline visbufferResolvePipeline;
  Fvog::GraphicsPipeline shadingPipeline;
  Fvog::ComputePipeline tonemapPipeline;
  //Fvog::GraphicsPipeline debugTexturePipeline;
  //Fvog::GraphicsPipeline debugLinesPipeline;
  //Fvog::GraphicsPipeline debugAabbsPipeline;
  //Fvog::GraphicsPipeline debugRectsPipeline;

  // Scene
  Utility::SceneMeshlet scene;

  // Punctual lights
  std::optional<Fvog::TypedBuffer<Utility::GpuLight>> lightBuffer;
  std::optional<Fvog::TypedBuffer<Utility::Meshlet>> meshletBuffer;

  Utility::SceneFlattened sceneFlattened;

  // Post processing
  std::optional<Fvog::Texture> noiseTexture;
  Fvog::NDeviceBuffer<TonemapUniforms> tonemapUniformBuffer;
  TonemapUniforms tonemapUniforms{};

  uint32_t renderWidth{};
  uint32_t renderHeight{};
  uint32_t seed = PCG::Hash(17);

#ifdef FROGRENDER_FSR2_ENABLE
  // FSR 2
  bool fsr2Enable = true;
  bool fsr2FirstInit = true;
  float fsr2Sharpness = 0;
  float fsr2Ratio = 1.5f; // FFX_FSR2_QUALITY_MODE_QUALITY
  FfxFsr2Context fsr2Context{};
  std::unique_ptr<char[]> fsr2ScratchMemory;
#else
  const bool fsr2Enable = false;
#endif

  // Magnifier
  float magnifierZoom = 4;
  glm::vec2 magnifierLastCursorPos = {400, 400};

  //// Bloom
  //Techniques::Bloom bloom;
  //bool bloomEnable = true;
  //uint32_t bloomPasses = 6;
  //float bloomStrength = 1.0f / 32.0f;
  //float bloomWidth = 1.0f;
  //bool bloomUseLowPassFilter = true;

  //// Auto-exposure
  //Techniques::AutoExposure autoExposure;
  //Fwog::TypedBuffer<float> exposureBuffer;
  //float autoExposureLogMinLuminance = -15.0f;
  //float autoExposureLogMaxLuminance = 15.0f;
  //// sRGB middle gray (https://en.wikipedia.org/wiki/Middle_gray)
  //float autoExposureTargetLuminance = 0.2140f;
  //float autoExposureAdjustmentSpeed = 1.0f;

  //// Camera
  //float cameraNearPlane = 0.1f;
  //float cameraFovyRadians = glm::radians(70.0f);

  //// VSM
  //Techniques::VirtualShadowMaps::Context vsmContext;
  //Techniques::VirtualShadowMaps::DirectionalVirtualShadowMap vsmSun;
  //Fwog::GraphicsPipeline vsmShadowPipeline;
  //Fwog::TypedBuffer<uint32_t> vsmShadowUniformBuffer;
  //Techniques::VirtualShadowMaps::Context::VsmGlobalUniforms vsmUniforms{};
  //float vsmFirstClipmapWidth = 10.0f;
  //float vsmDirectionalProjectionZLength = 100.0f;

  //// Texture viewer
  //struct ViewerUniforms
  //{
  //  int32_t texLayer = 0;
  //  int32_t texLevel = 0;
  //};

  //ViewerUniforms viewerUniforms{};
  //Fwog::TypedBuffer<ViewerUniforms> viewerUniformsBuffer;
  //const Fwog::Texture* viewerCurrentTexture = nullptr;
  //Fwog::GraphicsPipeline viewerVsmPageTablesPipeline;
  //Fwog::GraphicsPipeline viewerVsmPhysicalPagesPipeline;
  //Fwog::GraphicsPipeline viewerVsmBitmaskHzbPipeline;
  //std::optional<Fwog::Texture> viewerOutputTexture;


  // TODO: temp stuff
  VkSampler sampler{};
  VkPipelineLayout pipelineLayout{};
  std::optional<Fvog::GraphicsPipeline> pipeline;
  std::optional<Fvog::Texture> testTexture;
  std::optional<Fvog::Texture> testSampledTexture;
  std::optional<Fvog::Buffer> testUploadBuffer;
  std::optional<Fvog::NDeviceBuffer<std::byte>> updatedBuffer;
};